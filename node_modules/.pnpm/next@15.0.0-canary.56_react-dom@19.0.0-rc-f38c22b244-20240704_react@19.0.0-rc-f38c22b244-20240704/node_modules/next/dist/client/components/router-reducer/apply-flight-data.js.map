{"version":3,"sources":["../../../../src/client/components/router-reducer/apply-flight-data.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type { FlightDataPath } from '../../../server/app-render/types'\nimport { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'\nimport { fillCacheWithNewSubTreeData } from './fill-cache-with-new-subtree-data'\nimport type { PrefetchCacheEntry } from './router-reducer-types'\n\nexport function applyFlightData(\n  existingCache: CacheNode,\n  cache: CacheNode,\n  flightDataPath: FlightDataPath,\n  prefetchEntry?: PrefetchCacheEntry\n): boolean {\n  // The one before last item is the router state tree patch\n  const [treePatch, cacheNodeSeedData, head, layerAssets] =\n    flightDataPath.slice(-4)\n\n  // Handles case where prefetch only returns the router tree patch without rendered components.\n  if (cacheNodeSeedData === null) {\n    return false\n  }\n\n  if (flightDataPath.length === 4) {\n    const rsc = cacheNodeSeedData[2]\n    const loading = cacheNodeSeedData[3]\n    cache.loading = loading\n    cache.rsc = rsc\n    // This is a PPR-only field. When PPR is enabled, we shouldn't hit\n    // this path during a navigation, but until PPR is fully implemented\n    // yet it's possible the existing node does have a non-null\n    // `prefetchRsc`. As an incremental step, we'll just de-opt to the\n    // old behavior â€” no PPR value.\n    cache.prefetchRsc = null\n    fillLazyItemsTillLeafWithHead(\n      cache,\n      existingCache,\n      treePatch,\n      cacheNodeSeedData,\n      head,\n      layerAssets,\n      prefetchEntry\n    )\n  } else {\n    // Copy rsc for the root node of the cache.\n    cache.rsc = existingCache.rsc\n    // This is a PPR-only field. Unlike the previous branch, since we're\n    // just cloning the existing cache node, we might as well keep the\n    // PPR value, if it exists.\n    cache.prefetchRsc = existingCache.prefetchRsc\n    cache.parallelRoutes = new Map(existingCache.parallelRoutes)\n    cache.loading = existingCache.loading\n    // Create a copy of the existing cache with the rsc applied.\n    fillCacheWithNewSubTreeData(\n      cache,\n      existingCache,\n      flightDataPath,\n      prefetchEntry\n    )\n  }\n\n  return true\n}\n"],"names":["applyFlightData","existingCache","cache","flightDataPath","prefetchEntry","treePatch","cacheNodeSeedData","head","layerAssets","slice","length","rsc","loading","prefetchRsc","fillLazyItemsTillLeafWithHead","parallelRoutes","Map","fillCacheWithNewSubTreeData"],"mappings":";;;;+BAMgBA;;;eAAAA;;;+CAJ8B;6CACF;AAGrC,SAASA,gBACdC,aAAwB,EACxBC,KAAgB,EAChBC,cAA8B,EAC9BC,aAAkC;IAElC,0DAA0D;IAC1D,MAAM,CAACC,WAAWC,mBAAmBC,MAAMC,YAAY,GACrDL,eAAeM,KAAK,CAAC,CAAC;IAExB,8FAA8F;IAC9F,IAAIH,sBAAsB,MAAM;QAC9B,OAAO;IACT;IAEA,IAAIH,eAAeO,MAAM,KAAK,GAAG;QAC/B,MAAMC,MAAML,iBAAiB,CAAC,EAAE;QAChC,MAAMM,UAAUN,iBAAiB,CAAC,EAAE;QACpCJ,MAAMU,OAAO,GAAGA;QAChBV,MAAMS,GAAG,GAAGA;QACZ,kEAAkE;QAClE,oEAAoE;QACpE,2DAA2D;QAC3D,kEAAkE;QAClE,+BAA+B;QAC/BT,MAAMW,WAAW,GAAG;QACpBC,IAAAA,4DAA6B,EAC3BZ,OACAD,eACAI,WACAC,mBACAC,MACAC,aACAJ;IAEJ,OAAO;QACL,2CAA2C;QAC3CF,MAAMS,GAAG,GAAGV,cAAcU,GAAG;QAC7B,oEAAoE;QACpE,kEAAkE;QAClE,2BAA2B;QAC3BT,MAAMW,WAAW,GAAGZ,cAAcY,WAAW;QAC7CX,MAAMa,cAAc,GAAG,IAAIC,IAAIf,cAAcc,cAAc;QAC3Db,MAAMU,OAAO,GAAGX,cAAcW,OAAO;QACrC,4DAA4D;QAC5DK,IAAAA,wDAA2B,EACzBf,OACAD,eACAE,gBACAC;IAEJ;IAEA,OAAO;AACT"}