{"version":3,"sources":["../../../../src/client/components/router-reducer/fill-cache-with-new-subtree-data.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type {\n  FlightDataPath,\n  CacheNodeSeedData,\n} from '../../../server/app-render/types'\nimport { invalidateCacheByRouterState } from './invalidate-cache-by-router-state'\nimport { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport type { PrefetchCacheEntry } from './router-reducer-types'\n\n/**\n * Fill cache with rsc based on flightDataPath\n */\nexport function fillCacheWithNewSubTreeData(\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightDataPath: FlightDataPath,\n  prefetchEntry?: PrefetchCacheEntry\n): void {\n  const isLastEntry = flightDataPath.length <= 6\n  const [parallelRouteKey, segment] = flightDataPath\n\n  const cacheKey = createRouterCacheKey(segment)\n\n  const existingChildSegmentMap =\n    existingCache.parallelRoutes.get(parallelRouteKey)\n\n  if (!existingChildSegmentMap) {\n    // Bailout because the existing cache does not have the path to the leaf node\n    // Will trigger lazy fetch in layout-router because of missing segment\n    return\n  }\n\n  let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey)\n  if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n    childSegmentMap = new Map(existingChildSegmentMap)\n    newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap)\n  }\n\n  const existingChildCacheNode = existingChildSegmentMap.get(cacheKey)\n  let childCacheNode = childSegmentMap.get(cacheKey)\n\n  if (isLastEntry) {\n    if (\n      !childCacheNode ||\n      !childCacheNode.lazyData ||\n      childCacheNode === existingChildCacheNode\n    ) {\n      const seedData: CacheNodeSeedData = flightDataPath[3]\n      const layerAssets = flightDataPath[5]\n      const rsc = seedData[2]\n      const loading = seedData[3]\n      childCacheNode = {\n        lazyData: null,\n        rsc,\n        prefetchRsc: null,\n        head: null,\n        layerAssets,\n        prefetchLayerAssets: null,\n        prefetchHead: null,\n        loading,\n        // Ensure segments other than the one we got data for are preserved.\n        parallelRoutes: existingChildCacheNode\n          ? new Map(existingChildCacheNode.parallelRoutes)\n          : new Map(),\n      }\n\n      if (existingChildCacheNode) {\n        invalidateCacheByRouterState(\n          childCacheNode,\n          existingChildCacheNode,\n          flightDataPath[2]\n        )\n      }\n\n      fillLazyItemsTillLeafWithHead(\n        childCacheNode,\n        existingChildCacheNode,\n        flightDataPath[2],\n        seedData,\n        flightDataPath[4],\n        flightDataPath[5],\n        prefetchEntry\n      )\n\n      childSegmentMap.set(cacheKey, childCacheNode)\n    }\n    return\n  }\n\n  if (!childCacheNode || !existingChildCacheNode) {\n    // Bailout because the existing cache does not have the path to the leaf node\n    // Will trigger lazy fetch in layout-router because of missing segment\n    return\n  }\n\n  if (childCacheNode === existingChildCacheNode) {\n    childCacheNode = {\n      lazyData: childCacheNode.lazyData,\n      rsc: childCacheNode.rsc,\n      prefetchRsc: childCacheNode.prefetchRsc,\n      head: childCacheNode.head,\n      layerAssets: childCacheNode.layerAssets,\n      prefetchLayerAssets: childCacheNode.prefetchLayerAssets,\n      prefetchHead: childCacheNode.prefetchHead,\n      parallelRoutes: new Map(childCacheNode.parallelRoutes),\n      loading: childCacheNode.loading,\n    } as CacheNode\n    childSegmentMap.set(cacheKey, childCacheNode)\n  }\n\n  fillCacheWithNewSubTreeData(\n    childCacheNode,\n    existingChildCacheNode,\n    flightDataPath.slice(2),\n    prefetchEntry\n  )\n}\n"],"names":["fillCacheWithNewSubTreeData","newCache","existingCache","flightDataPath","prefetchEntry","isLastEntry","length","parallelRouteKey","segment","cacheKey","createRouterCacheKey","existingChildSegmentMap","parallelRoutes","get","childSegmentMap","Map","set","existingChildCacheNode","childCacheNode","lazyData","seedData","layerAssets","rsc","loading","prefetchRsc","head","prefetchLayerAssets","prefetchHead","invalidateCacheByRouterState","fillLazyItemsTillLeafWithHead","slice"],"mappings":";;;;+BAagBA;;;eAAAA;;;8CAR6B;+CACC;sCACT;AAM9B,SAASA,4BACdC,QAAmB,EACnBC,aAAwB,EACxBC,cAA8B,EAC9BC,aAAkC;IAElC,MAAMC,cAAcF,eAAeG,MAAM,IAAI;IAC7C,MAAM,CAACC,kBAAkBC,QAAQ,GAAGL;IAEpC,MAAMM,WAAWC,IAAAA,0CAAoB,EAACF;IAEtC,MAAMG,0BACJT,cAAcU,cAAc,CAACC,GAAG,CAACN;IAEnC,IAAI,CAACI,yBAAyB;QAC5B,6EAA6E;QAC7E,sEAAsE;QACtE;IACF;IAEA,IAAIG,kBAAkBb,SAASW,cAAc,CAACC,GAAG,CAACN;IAClD,IAAI,CAACO,mBAAmBA,oBAAoBH,yBAAyB;QACnEG,kBAAkB,IAAIC,IAAIJ;QAC1BV,SAASW,cAAc,CAACI,GAAG,CAACT,kBAAkBO;IAChD;IAEA,MAAMG,yBAAyBN,wBAAwBE,GAAG,CAACJ;IAC3D,IAAIS,iBAAiBJ,gBAAgBD,GAAG,CAACJ;IAEzC,IAAIJ,aAAa;QACf,IACE,CAACa,kBACD,CAACA,eAAeC,QAAQ,IACxBD,mBAAmBD,wBACnB;YACA,MAAMG,WAA8BjB,cAAc,CAAC,EAAE;YACrD,MAAMkB,cAAclB,cAAc,CAAC,EAAE;YACrC,MAAMmB,MAAMF,QAAQ,CAAC,EAAE;YACvB,MAAMG,UAAUH,QAAQ,CAAC,EAAE;YAC3BF,iBAAiB;gBACfC,UAAU;gBACVG;gBACAE,aAAa;gBACbC,MAAM;gBACNJ;gBACAK,qBAAqB;gBACrBC,cAAc;gBACdJ;gBACA,oEAAoE;gBACpEX,gBAAgBK,yBACZ,IAAIF,IAAIE,uBAAuBL,cAAc,IAC7C,IAAIG;YACV;YAEA,IAAIE,wBAAwB;gBAC1BW,IAAAA,0DAA4B,EAC1BV,gBACAD,wBACAd,cAAc,CAAC,EAAE;YAErB;YAEA0B,IAAAA,4DAA6B,EAC3BX,gBACAD,wBACAd,cAAc,CAAC,EAAE,EACjBiB,UACAjB,cAAc,CAAC,EAAE,EACjBA,cAAc,CAAC,EAAE,EACjBC;YAGFU,gBAAgBE,GAAG,CAACP,UAAUS;QAChC;QACA;IACF;IAEA,IAAI,CAACA,kBAAkB,CAACD,wBAAwB;QAC9C,6EAA6E;QAC7E,sEAAsE;QACtE;IACF;IAEA,IAAIC,mBAAmBD,wBAAwB;QAC7CC,iBAAiB;YACfC,UAAUD,eAAeC,QAAQ;YACjCG,KAAKJ,eAAeI,GAAG;YACvBE,aAAaN,eAAeM,WAAW;YACvCC,MAAMP,eAAeO,IAAI;YACzBJ,aAAaH,eAAeG,WAAW;YACvCK,qBAAqBR,eAAeQ,mBAAmB;YACvDC,cAAcT,eAAeS,YAAY;YACzCf,gBAAgB,IAAIG,IAAIG,eAAeN,cAAc;YACrDW,SAASL,eAAeK,OAAO;QACjC;QACAT,gBAAgBE,GAAG,CAACP,UAAUS;IAChC;IAEAlB,4BACEkB,gBACAD,wBACAd,eAAe2B,KAAK,CAAC,IACrB1B;AAEJ"}