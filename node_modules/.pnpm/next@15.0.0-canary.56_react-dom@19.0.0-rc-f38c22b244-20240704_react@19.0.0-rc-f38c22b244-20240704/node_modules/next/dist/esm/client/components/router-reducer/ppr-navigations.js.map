{"version":3,"sources":["../../../../src/client/components/router-reducer/ppr-navigations.ts"],"sourcesContent":["import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  FlightSegmentPath,\n  Segment,\n} from '../../../server/app-render/types'\nimport type {\n  CacheNode,\n  ChildSegmentMap,\n  ReadyCacheNode,\n} from '../../../shared/lib/app-router-context.shared-runtime'\nimport {\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport type { FetchServerResponseResult } from './fetch-server-response'\n\n// This is yet another tree type that is used to track pending promises that\n// need to be fulfilled once the dynamic data is received. The terminal nodes of\n// this tree represent the new Cache Node trees that were created during this\n// request. We can't use the Cache Node tree or Route State tree directly\n// because those include reused nodes, too. This tree is discarded as soon as\n// the navigation response is received.\ntype Task = {\n  // The router state that corresponds to the tree that this Task represents.\n  route: FlightRouterState\n  // This is usually non-null. It represents a brand new Cache Node tree whose\n  // data is still pending. If it's null, it means there's no pending data but\n  // the client patched the router state.\n  node: CacheNode | null\n  children: Map<string, Task> | null\n}\n\n// Creates a new Cache Node tree (i.e. copy-on-write) that represents the\n// optimistic result of a navigation, using both the current Cache Node tree and\n// data that was prefetched prior to navigation.\n//\n// At the moment we call this function, we haven't yet received the navigation\n// response from the server. It could send back something completely different\n// from the tree that was prefetched — due to rewrites, default routes, parallel\n// routes, etc.\n//\n// But in most cases, it will return the same tree that we prefetched, just with\n// the dynamic holes filled in. So we optimistically assume this will happen,\n// and accept that the real result could be arbitrarily different.\n//\n// We'll reuse anything that was already in the previous tree, since that's what\n// the server does.\n//\n// New segments (ones that don't appear in the old tree) are assigned an\n// unresolved promise. The data for these promises will be fulfilled later, when\n// the navigation response is received.\n//\n// The tree can be rendered immediately after it is created (that's why this is\n// a synchronous function). Any new trees that do not have prefetch data will\n// suspend during rendering, until the dynamic data streams in.\n//\n// Returns a Task object, which contains both the updated Cache Node and a path\n// to the pending subtrees that need to be resolved by the navigation response.\n//\n// A return value of `null` means there were no changes, and the previous tree\n// can be reused without initiating a server request.\nexport function updateCacheNodeOnNavigation(\n  oldCacheNode: CacheNode,\n  oldRouterState: FlightRouterState,\n  newRouterState: FlightRouterState,\n  prefetchData: CacheNodeSeedData,\n  prefetchHead: React.ReactNode,\n  prefetchLayerAssets: React.ReactNode\n): Task | null {\n  // Diff the old and new trees to reuse the shared layouts.\n  const oldRouterStateChildren = oldRouterState[1]\n  const newRouterStateChildren = newRouterState[1]\n  const prefetchDataChildren = prefetchData[1]\n\n  const oldParallelRoutes = oldCacheNode.parallelRoutes\n\n  // Clone the current set of segment children, even if they aren't active in\n  // the new tree.\n  // TODO: We currently retain all the inactive segments indefinitely, until\n  // there's an explicit refresh, or a parent layout is lazily refreshed. We\n  // rely on this for popstate navigations, which update the Router State Tree\n  // but do not eagerly perform a data fetch, because they expect the segment\n  // data to already be in the Cache Node tree. For highly static sites that\n  // are mostly read-only, this may happen only rarely, causing memory to\n  // leak. We should figure out a better model for the lifetime of inactive\n  // segments, so we can maintain instant back/forward navigations without\n  // leaking memory indefinitely.\n  const prefetchParallelRoutes = new Map(oldParallelRoutes)\n\n  // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)\n  // the Route Tree that was returned by the server — for example, in the case\n  // of default parallel routes, we preserve the currently active segment. To\n  // avoid mutating the original tree, we clone the router state children along\n  // the return path.\n  let patchedRouterStateChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let taskChildren = null\n  for (let parallelRouteKey in newRouterStateChildren) {\n    const newRouterStateChild: FlightRouterState =\n      newRouterStateChildren[parallelRouteKey]\n    const oldRouterStateChild: FlightRouterState | void =\n      oldRouterStateChildren[parallelRouteKey]\n    const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey)\n    const prefetchDataChild: CacheNodeSeedData | void | null =\n      prefetchDataChildren[parallelRouteKey]\n\n    const newSegmentChild = newRouterStateChild[0]\n    const newSegmentKeyChild = createRouterCacheKey(newSegmentChild)\n\n    const oldSegmentChild =\n      oldRouterStateChild !== undefined ? oldRouterStateChild[0] : undefined\n\n    const oldCacheNodeChild =\n      oldSegmentMapChild !== undefined\n        ? oldSegmentMapChild.get(newSegmentKeyChild)\n        : undefined\n\n    let taskChild: Task | null\n    if (newSegmentChild === PAGE_SEGMENT_KEY) {\n      // This is a leaf segment — a page, not a shared layout. We always apply\n      // its data.\n      taskChild = spawnPendingTask(\n        newRouterStateChild,\n        prefetchDataChild !== undefined ? prefetchDataChild : null,\n        prefetchHead,\n        prefetchLayerAssets\n      )\n    } else if (newSegmentChild === DEFAULT_SEGMENT_KEY) {\n      // This is another kind of leaf segment — a default route.\n      //\n      // Default routes have special behavior. When there's no matching segment\n      // for a parallel route, Next.js preserves the currently active segment\n      // during a client navigation — but not for initial render. The server\n      // leaves it to the client to account for this. So we need to handle\n      // it here.\n      if (oldRouterStateChild !== undefined) {\n        // Reuse the existing Router State for this segment. We spawn a \"task\"\n        // just to keep track of the updated router state; unlike most, it's\n        // already fulfilled and won't be affected by the dynamic response.\n        taskChild = spawnReusedTask(oldRouterStateChild)\n      } else {\n        // There's no currently active segment. Switch to the \"create\" path.\n        taskChild = spawnPendingTask(\n          newRouterStateChild,\n          prefetchDataChild !== undefined ? prefetchDataChild : null,\n          prefetchHead,\n          prefetchLayerAssets\n        )\n      }\n    } else if (\n      oldSegmentChild !== undefined &&\n      matchSegment(newSegmentChild, oldSegmentChild)\n    ) {\n      if (\n        oldCacheNodeChild !== undefined &&\n        oldRouterStateChild !== undefined\n      ) {\n        // This segment exists in both the old and new trees.\n        if (prefetchDataChild !== undefined && prefetchDataChild !== null) {\n          // Recursively update the children.\n          taskChild = updateCacheNodeOnNavigation(\n            oldCacheNodeChild,\n            oldRouterStateChild,\n            newRouterStateChild,\n            prefetchDataChild,\n            prefetchHead,\n            prefetchLayerAssets\n          )\n        } else {\n          // The server didn't send any prefetch data for this segment. This\n          // shouldn't happen because the Route Tree and the Seed Data tree\n          // should always be the same shape, but until we unify those types\n          // it's still possible. For now we're going to deopt and trigger a\n          // lazy fetch during render.\n          taskChild = spawnTaskForMissingData(newRouterStateChild)\n        }\n      } else {\n        // Either there's no existing Cache Node for this segment, or this\n        // segment doesn't exist in the old Router State tree. Switch to the\n        // \"create\" path.\n        taskChild = spawnPendingTask(\n          newRouterStateChild,\n          prefetchDataChild !== undefined ? prefetchDataChild : null,\n          prefetchHead,\n          prefetchLayerAssets\n        )\n      }\n    } else {\n      // This is a new tree. Switch to the \"create\" path.\n      taskChild = spawnPendingTask(\n        newRouterStateChild,\n        prefetchDataChild !== undefined ? prefetchDataChild : null,\n        prefetchHead,\n        prefetchLayerAssets\n      )\n    }\n\n    if (taskChild !== null) {\n      // Something changed in the child tree. Keep track of the child task.\n      if (taskChildren === null) {\n        taskChildren = new Map()\n      }\n      taskChildren.set(parallelRouteKey, taskChild)\n      const newCacheNodeChild = taskChild.node\n      if (newCacheNodeChild !== null) {\n        const newSegmentMapChild: ChildSegmentMap = new Map(oldSegmentMapChild)\n        newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild)\n        prefetchParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n      }\n\n      // The child tree's route state may be different from the prefetched\n      // route sent by the server. We need to clone it as we traverse back up\n      // the tree.\n      patchedRouterStateChildren[parallelRouteKey] = taskChild.route\n    } else {\n      // The child didn't change. We can use the prefetched router state.\n      patchedRouterStateChildren[parallelRouteKey] = newRouterStateChild\n    }\n  }\n\n  if (taskChildren === null) {\n    // No new tasks were spawned.\n    return null\n  }\n\n  const newCacheNode: ReadyCacheNode = {\n    lazyData: null,\n    rsc: oldCacheNode.rsc,\n    // We intentionally aren't updating the prefetchRsc field, since this node\n    // is already part of the current tree, because it would be weird for\n    // prefetch data to be newer than the final data. It probably won't ever be\n    // observable anyway, but it could happen if the segment is unmounted then\n    // mounted again, because LayoutRouter will momentarily switch to rendering\n    // prefetchRsc, via useDeferredValue.\n    prefetchRsc: oldCacheNode.prefetchRsc,\n    head: oldCacheNode.head,\n    prefetchHead: oldCacheNode.prefetchHead,\n    layerAssets: oldCacheNode.layerAssets,\n    prefetchLayerAssets: oldCacheNode.prefetchLayerAssets,\n    loading: oldCacheNode.loading,\n\n    // Everything is cloned except for the children, which we computed above.\n    parallelRoutes: prefetchParallelRoutes,\n  }\n\n  return {\n    // Return a cloned copy of the router state with updated children.\n    route: patchRouterStateWithNewChildren(\n      newRouterState,\n      patchedRouterStateChildren\n    ),\n    node: newCacheNode,\n    children: taskChildren,\n  }\n}\n\nfunction patchRouterStateWithNewChildren(\n  baseRouterState: FlightRouterState,\n  newChildren: { [parallelRouteKey: string]: FlightRouterState }\n): FlightRouterState {\n  const clone: FlightRouterState = [baseRouterState[0], newChildren]\n  // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n  // confirm whether we need to copy all of these fields. Not sure the server\n  // ever sends, e.g. the refetch marker.\n  if (2 in baseRouterState) {\n    clone[2] = baseRouterState[2]\n  }\n  if (3 in baseRouterState) {\n    clone[3] = baseRouterState[3]\n  }\n  if (4 in baseRouterState) {\n    clone[4] = baseRouterState[4]\n  }\n  return clone\n}\n\nfunction spawnPendingTask(\n  routerState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: React.ReactNode,\n  prefetchLayerAssets: React.ReactNode\n): Task {\n  // Create a task that will later be fulfilled by data from the server.\n  const pendingCacheNode = createPendingCacheNode(\n    routerState,\n    prefetchData,\n    prefetchHead,\n    prefetchLayerAssets\n  )\n  return {\n    route: routerState,\n    node: pendingCacheNode,\n    children: null,\n  }\n}\n\nfunction spawnReusedTask(reusedRouterState: FlightRouterState): Task {\n  // Create a task that reuses an existing segment, e.g. when reusing\n  // the current active segment in place of a default route.\n  return {\n    route: reusedRouterState,\n    node: null,\n    children: null,\n  }\n}\n\nfunction spawnTaskForMissingData(routerState: FlightRouterState): Task {\n  // Create a task for a new subtree that wasn't prefetched by the server.\n  // This shouldn't really ever happen but it's here just in case the Seed Data\n  // Tree and the Router State Tree disagree unexpectedly.\n  const pendingCacheNode = createPendingCacheNode(routerState, null, null, null)\n  return {\n    route: routerState,\n    node: pendingCacheNode,\n    children: null,\n  }\n}\n\n// Writes a dynamic server response into the tree created by\n// updateCacheNodeOnNavigation. All pending promises that were spawned by the\n// navigation will be resolved, either with dynamic data from the server, or\n// `null` to indicate that the data is missing.\n//\n// A `null` value will trigger a lazy fetch during render, which will then patch\n// up the tree using the same mechanism as the non-PPR implementation\n// (serverPatchReducer).\n//\n// Usually, the server will respond with exactly the subset of data that we're\n// waiting for — everything below the nearest shared layout. But technically,\n// the server can return anything it wants.\n//\n// This does _not_ create a new tree; it modifies the existing one in place.\n// Which means it must follow the Suspense rules of cache safety.\nexport function listenForDynamicRequest(\n  task: Task,\n  responsePromise: Promise<FetchServerResponseResult>\n) {\n  responsePromise.then(\n    (response: FetchServerResponseResult) => {\n      const flightData = response[0]\n      for (const flightDataPath of flightData) {\n        const segmentPath = flightDataPath.slice(0, -4)\n        const serverRouterState = flightDataPath[flightDataPath.length - 4]\n        const dynamicData = flightDataPath[flightDataPath.length - 3]\n        const dynamicHead = flightDataPath[flightDataPath.length - 2]\n        const dynamicLayerAssets = flightDataPath[flightDataPath.length - 1]\n\n        if (typeof segmentPath === 'string') {\n          // Happens when navigating to page in `pages` from `app`. We shouldn't\n          // get here because should have already handled this during\n          // the prefetch.\n          continue\n        }\n\n        writeDynamicDataIntoPendingTask(\n          task,\n          segmentPath,\n          serverRouterState,\n          dynamicData,\n          dynamicHead,\n          dynamicLayerAssets\n        )\n      }\n\n      // Now that we've exhausted all the data we received from the server, if\n      // there are any remaining pending tasks in the tree, abort them now.\n      // If there's any missing data, it will trigger a lazy fetch.\n      abortTask(task, null)\n    },\n    (error: any) => {\n      // This will trigger an error during render\n      abortTask(task, error)\n    }\n  )\n}\n\nfunction writeDynamicDataIntoPendingTask(\n  rootTask: Task,\n  segmentPath: FlightSegmentPath,\n  serverRouterState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: React.ReactNode,\n  dynamicLayerAssets: React.ReactNode\n) {\n  // The data sent by the server represents only a subtree of the app. We need\n  // to find the part of the task tree that matches the server response, and\n  // fulfill it using the dynamic data.\n  //\n  // segmentPath represents the parent path of subtree. It's a repeating pattern\n  // of parallel route key and segment:\n  //\n  //   [string, Segment, string, Segment, string, Segment, ...]\n  //\n  // Iterate through the path and finish any tasks that match this payload.\n  let task = rootTask\n  for (let i = 0; i < segmentPath.length; i += 2) {\n    const parallelRouteKey: string = segmentPath[i]\n    const segment: Segment = segmentPath[i + 1]\n    const taskChildren = task.children\n    if (taskChildren !== null) {\n      const taskChild = taskChildren.get(parallelRouteKey)\n      if (taskChild !== undefined) {\n        const taskSegment = taskChild.route[0]\n        if (matchSegment(segment, taskSegment)) {\n          // Found a match for this task. Keep traversing down the task tree.\n          task = taskChild\n          continue\n        }\n      }\n    }\n    // We didn't find a child task that matches the server data. Exit. We won't\n    // abort the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n    return\n  }\n\n  finishTaskUsingDynamicDataPayload(\n    task,\n    serverRouterState,\n    dynamicData,\n    dynamicHead,\n    dynamicLayerAssets\n  )\n}\n\nfunction finishTaskUsingDynamicDataPayload(\n  task: Task,\n  serverRouterState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: React.ReactNode,\n  dynamicLayerAssets: React.ReactNode\n) {\n  // dynamicData may represent a larger subtree than the task. Before we can\n  // finish the task, we need to line them up.\n  const taskChildren = task.children\n  const taskNode = task.node\n  if (taskChildren === null) {\n    // We've reached the leaf node of the pending task. The server data tree\n    // lines up the pending Cache Node tree. We can now switch to the\n    // normal algorithm.\n    if (taskNode !== null) {\n      finishPendingCacheNode(\n        taskNode,\n        task.route,\n        serverRouterState,\n        dynamicData,\n        dynamicHead,\n        dynamicLayerAssets\n      )\n      // Null this out to indicate that the task is complete.\n      task.node = null\n    }\n    return\n  }\n  // The server returned more data than we need to finish the task. Skip over\n  // the extra segments until we reach the leaf task node.\n  const serverChildren = serverRouterState[1]\n  const dynamicDataChildren = dynamicData[1]\n\n  for (const parallelRouteKey in serverRouterState) {\n    const serverRouterStateChild: FlightRouterState =\n      serverChildren[parallelRouteKey]\n    const dynamicDataChild: CacheNodeSeedData | null | void =\n      dynamicDataChildren[parallelRouteKey]\n\n    const taskChild = taskChildren.get(parallelRouteKey)\n    if (taskChild !== undefined) {\n      const taskSegment = taskChild.route[0]\n      if (\n        matchSegment(serverRouterStateChild[0], taskSegment) &&\n        dynamicDataChild !== null &&\n        dynamicDataChild !== undefined\n      ) {\n        // Found a match for this task. Keep traversing down the task tree.\n        return finishTaskUsingDynamicDataPayload(\n          taskChild,\n          serverRouterStateChild,\n          dynamicDataChild,\n          dynamicHead,\n          dynamicLayerAssets\n        )\n      }\n    }\n    // We didn't find a child task that matches the server data. We won't abort\n    // the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n  }\n}\n\nfunction createPendingCacheNode(\n  routerState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: React.ReactNode,\n  prefetchLayerAssets: React.ReactNode\n): ReadyCacheNode {\n  const routerStateChildren = routerState[1]\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n\n  const parallelRoutes = new Map()\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const prefetchDataChild: CacheNodeSeedData | null | void =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n\n    const newCacheNodeChild = createPendingCacheNode(\n      routerStateChild,\n      prefetchDataChild === undefined ? null : prefetchDataChild,\n      prefetchHead,\n      prefetchLayerAssets\n    )\n\n    const newSegmentMapChild: ChildSegmentMap = new Map()\n    newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n    parallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n  }\n\n  // The head is assigned to every leaf segment delivered by the server. Based\n  // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n  const isLeafSegment = parallelRoutes.size === 0\n\n  const maybePrefetchRsc = prefetchData !== null ? prefetchData[2] : null\n  const maybePrefetchLoading = prefetchData !== null ? prefetchData[3] : null\n  return {\n    lazyData: null,\n    parallelRoutes: parallelRoutes,\n\n    prefetchRsc: maybePrefetchRsc !== undefined ? maybePrefetchRsc : null,\n    prefetchHead: isLeafSegment ? prefetchHead : null,\n    prefetchLayerAssets,\n    loading: maybePrefetchLoading !== undefined ? maybePrefetchLoading : null,\n\n    // Create a deferred promise. This will be fulfilled once the dynamic\n    // response is received from the server.\n    rsc: createDeferredRsc() as React.ReactNode,\n    head: isLeafSegment ? (createDeferredRsc() as React.ReactNode) : null,\n    layerAssets: createDeferredRsc() as React.ReactNode,\n  }\n}\n\nfunction finishPendingCacheNode(\n  cacheNode: CacheNode,\n  taskState: FlightRouterState,\n  serverState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: React.ReactNode,\n  dynamicLayerAssets: React.ReactNode\n): void {\n  // Writes a dynamic response into an existing Cache Node tree. This does _not_\n  // create a new tree, it updates the existing tree in-place. So it must follow\n  // the Suspense rules of cache safety — it can resolve pending promises, but\n  // it cannot overwrite existing data. It can add segments to the tree (because\n  // a missing segment will cause the layout router to suspend).\n  // but it cannot delete them.\n  //\n  // We must resolve every promise in the tree, or else it will suspend\n  // indefinitely. If we did not receive data for a segment, we will resolve its\n  // data promise to `null` to trigger a lazy fetch during render.\n  const taskStateChildren = taskState[1]\n  const serverStateChildren = serverState[1]\n  const dataChildren = dynamicData[1]\n\n  // The router state that we traverse the tree with (taskState) is the same one\n  // that we used to construct the pending Cache Node tree. That way we're sure\n  // to resolve all the pending promises.\n  const parallelRoutes = cacheNode.parallelRoutes\n  for (let parallelRouteKey in taskStateChildren) {\n    const taskStateChild: FlightRouterState =\n      taskStateChildren[parallelRouteKey]\n    const serverStateChild: FlightRouterState | void =\n      serverStateChildren[parallelRouteKey]\n    const dataChild: CacheNodeSeedData | null | void =\n      dataChildren[parallelRouteKey]\n\n    const segmentMapChild = parallelRoutes.get(parallelRouteKey)\n    const taskSegmentChild = taskStateChild[0]\n    const taskSegmentKeyChild = createRouterCacheKey(taskSegmentChild)\n\n    const cacheNodeChild =\n      segmentMapChild !== undefined\n        ? segmentMapChild.get(taskSegmentKeyChild)\n        : undefined\n\n    if (cacheNodeChild !== undefined) {\n      if (\n        serverStateChild !== undefined &&\n        matchSegment(taskSegmentChild, serverStateChild[0])\n      ) {\n        if (dataChild !== undefined && dataChild !== null) {\n          // This is the happy path. Recursively update all the children.\n          finishPendingCacheNode(\n            cacheNodeChild,\n            taskStateChild,\n            serverStateChild,\n            dataChild,\n            dynamicHead,\n            dynamicLayerAssets\n          )\n        } else {\n          // The server never returned data for this segment. Trigger a lazy\n          // fetch during render. This shouldn't happen because the Route Tree\n          // and the Seed Data tree sent by the server should always be the same\n          // shape when part of the same server response.\n          abortPendingCacheNode(taskStateChild, cacheNodeChild, null)\n        }\n      } else {\n        // The server never returned data for this segment. Trigger a lazy\n        // fetch during render.\n        abortPendingCacheNode(taskStateChild, cacheNodeChild, null)\n      }\n    } else {\n      // The server response matches what was expected to receive, but there's\n      // no matching Cache Node in the task tree. This is a bug in the\n      // implementation because we should have created a node for every\n      // segment in the tree that's associated with this task.\n    }\n  }\n\n  // Use the dynamic data from the server to fulfill the deferred RSC promise\n  // on the Cache Node.\n  const rsc = cacheNode.rsc\n  const dynamicSegmentData = dynamicData[2]\n  if (rsc === null) {\n    // This is a lazy cache node. We can overwrite it. This is only safe\n    // because we know that the LayoutRouter suspends if `rsc` is `null`.\n    cacheNode.rsc = dynamicSegmentData\n  } else if (isDeferredRsc(rsc)) {\n    // This is a deferred RSC promise. We can fulfill it with the data we just\n    // received from the server. If it was already resolved by a different\n    // navigation, then this does nothing because we can't overwrite data.\n    rsc.resolve(dynamicSegmentData)\n  } else {\n    // This is not a deferred RSC promise, nor is it empty, so it must have\n    // been populated by a different navigation. We must not overwrite it.\n  }\n\n  // Use the dynamic data from the server to fulfill the deferred layerAssets.\n  const layerAssets = cacheNode.layerAssets\n  if (isDeferredRsc(layerAssets)) {\n    layerAssets.resolve(dynamicLayerAssets)\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved with the dynamic head from\n  // the server.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(dynamicHead)\n  }\n}\n\nexport function abortTask(task: Task, error: any): void {\n  const cacheNode = task.node\n  if (cacheNode === null) {\n    // This indicates the task is already complete.\n    return\n  }\n\n  const taskChildren = task.children\n  if (taskChildren === null) {\n    // Reached the leaf task node. This is the root of a pending cache\n    // node tree.\n    abortPendingCacheNode(task.route, cacheNode, error)\n  } else {\n    // This is an intermediate task node. Keep traversing until we reach a\n    // task node with no children. That will be the root of the cache node tree\n    // that needs to be resolved.\n    for (const taskChild of taskChildren.values()) {\n      abortTask(taskChild, error)\n    }\n  }\n\n  // Null this out to indicate that the task is complete.\n  task.node = null\n}\n\nfunction abortPendingCacheNode(\n  routerState: FlightRouterState,\n  cacheNode: CacheNode,\n  error: any\n): void {\n  // For every pending segment in the tree, resolve its `rsc` promise to `null`\n  // to trigger a lazy fetch during render.\n  //\n  // Or, if an error object is provided, it will error instead.\n  const routerStateChildren = routerState[1]\n  const parallelRoutes = cacheNode.parallelRoutes\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const segmentMapChild = parallelRoutes.get(parallelRouteKey)\n    if (segmentMapChild === undefined) {\n      // This shouldn't happen because we're traversing the same tree that was\n      // used to construct the cache nodes in the first place.\n      continue\n    }\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n    const cacheNodeChild = segmentMapChild.get(segmentKeyChild)\n    if (cacheNodeChild !== undefined) {\n      abortPendingCacheNode(routerStateChild, cacheNodeChild, error)\n    } else {\n      // This shouldn't happen because we're traversing the same tree that was\n      // used to construct the cache nodes in the first place.\n    }\n  }\n  const rsc = cacheNode.rsc\n  if (isDeferredRsc(rsc)) {\n    if (error === null) {\n      // This will trigger a lazy fetch during render.\n      rsc.resolve(null)\n    } else {\n      // This will trigger an error during rendering.\n      rsc.reject(error)\n    }\n  }\n\n  // If layerAssets is pending, resolve it with an error. Since the RSC is part\n  // part of the same response, the error will already be handled above.\n  const layerAssets = cacheNode.layerAssets\n  if (isDeferredRsc(layerAssets)) {\n    layerAssets.resolve(null)\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved. If an error was provided, we\n  // will not resolve it with an error, since this is rendered at the root of\n  // the app. We want the segment to error, not the entire app.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(null)\n  }\n}\n\nexport function updateCacheNodeOnPopstateRestoration(\n  oldCacheNode: CacheNode,\n  routerState: FlightRouterState\n) {\n  // A popstate navigation reads data from the local cache. It does not issue\n  // new network requests (unless the cache entries have been evicted). So, we\n  // update the cache to drop the prefetch  data for any segment whose dynamic\n  // data was already received. This prevents an unnecessary flash back to PPR\n  // state during a back/forward navigation.\n  //\n  // This function clones the entire cache node tree and sets the `prefetchRsc`\n  // field to `null` to prevent it from being rendered. We can't mutate the node\n  // in place because this is a concurrent data structure.\n\n  const routerStateChildren = routerState[1]\n  const oldParallelRoutes = oldCacheNode.parallelRoutes\n  const newParallelRoutes = new Map(oldParallelRoutes)\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n    const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey)\n    if (oldSegmentMapChild !== undefined) {\n      const oldCacheNodeChild = oldSegmentMapChild.get(segmentKeyChild)\n      if (oldCacheNodeChild !== undefined) {\n        const newCacheNodeChild = updateCacheNodeOnPopstateRestoration(\n          oldCacheNodeChild,\n          routerStateChild\n        )\n        const newSegmentMapChild = new Map(oldSegmentMapChild)\n        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n        newParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n      }\n    }\n  }\n\n  // Only show prefetched data if the dynamic data is still pending.\n  //\n  // Tehnically, what we're actually checking is whether the dynamic network\n  // response was received. But since it's a streaming response, this does not\n  // mean that all the dynamic data has fully streamed in. It just means that\n  // _some_ of the dynamic data was received. But as a heuristic, we assume that\n  // the rest dynamic data will stream in quickly, so it's still better to skip\n  // the prefetch state.\n  const rsc = oldCacheNode.rsc\n  const shouldUsePrefetch = isDeferredRsc(rsc) && rsc.status === 'pending'\n\n  return {\n    lazyData: null,\n    rsc,\n    head: oldCacheNode.head,\n    layerAssets: oldCacheNode.layerAssets,\n\n    prefetchLayerAssets: shouldUsePrefetch\n      ? oldCacheNode.prefetchLayerAssets\n      : null,\n    prefetchHead: shouldUsePrefetch ? oldCacheNode.prefetchHead : null,\n    prefetchRsc: shouldUsePrefetch ? oldCacheNode.prefetchRsc : null,\n    loading: shouldUsePrefetch ? oldCacheNode.loading : null,\n\n    // These are the cloned children we computed above\n    parallelRoutes: newParallelRoutes,\n  }\n}\n\nconst DEFERRED = Symbol()\n\ntype PendingDeferredRsc = Promise<React.ReactNode> & {\n  status: 'pending'\n  resolve: (value: React.ReactNode) => void\n  reject: (error: any) => void\n  tag: Symbol\n}\n\ntype FulfilledDeferredRsc = Promise<React.ReactNode> & {\n  status: 'fulfilled'\n  value: React.ReactNode\n  resolve: (value: React.ReactNode) => void\n  reject: (error: any) => void\n  tag: Symbol\n}\n\ntype RejectedDeferredRsc = Promise<React.ReactNode> & {\n  status: 'rejected'\n  reason: any\n  resolve: (value: React.ReactNode) => void\n  reject: (error: any) => void\n  tag: Symbol\n}\n\ntype DeferredRsc =\n  | PendingDeferredRsc\n  | FulfilledDeferredRsc\n  | RejectedDeferredRsc\n\n// This type exists to distinguish a DeferredRsc from a Flight promise. It's a\n// compromise to avoid adding an extra field on every Cache Node, which would be\n// awkward because the pre-PPR parts of codebase would need to account for it,\n// too. We can remove it once type Cache Node type is more settled.\nfunction isDeferredRsc(value: any): value is DeferredRsc {\n  return value && value.tag === DEFERRED\n}\n\nfunction createDeferredRsc(): PendingDeferredRsc {\n  let resolve: any\n  let reject: any\n  const pendingRsc = new Promise<React.ReactNode>((res, rej) => {\n    resolve = res\n    reject = rej\n  }) as PendingDeferredRsc\n  pendingRsc.status = 'pending'\n  pendingRsc.resolve = (value: React.ReactNode) => {\n    if (pendingRsc.status === 'pending') {\n      const fulfilledRsc: FulfilledDeferredRsc = pendingRsc as any\n      fulfilledRsc.status = 'fulfilled'\n      fulfilledRsc.value = value\n      resolve(value)\n    }\n  }\n  pendingRsc.reject = (error: any) => {\n    if (pendingRsc.status === 'pending') {\n      const rejectedRsc: RejectedDeferredRsc = pendingRsc as any\n      rejectedRsc.status = 'rejected'\n      rejectedRsc.reason = error\n      reject(error)\n    }\n  }\n  pendingRsc.tag = DEFERRED\n  return pendingRsc\n}\n"],"names":["DEFAULT_SEGMENT_KEY","PAGE_SEGMENT_KEY","matchSegment","createRouterCacheKey","updateCacheNodeOnNavigation","oldCacheNode","oldRouterState","newRouterState","prefetchData","prefetchHead","prefetchLayerAssets","oldRouterStateChildren","newRouterStateChildren","prefetchDataChildren","oldParallelRoutes","parallelRoutes","prefetchParallelRoutes","Map","patchedRouterStateChildren","taskChildren","parallelRouteKey","newRouterStateChild","oldRouterStateChild","oldSegmentMapChild","get","prefetchDataChild","newSegmentChild","newSegmentKeyChild","oldSegmentChild","undefined","oldCacheNodeChild","taskChild","spawnPendingTask","spawnReusedTask","spawnTaskForMissingData","set","newCacheNodeChild","node","newSegmentMapChild","route","newCacheNode","lazyData","rsc","prefetchRsc","head","layerAssets","loading","patchRouterStateWithNewChildren","children","baseRouterState","newChildren","clone","routerState","pendingCacheNode","createPendingCacheNode","reusedRouterState","listenForDynamicRequest","task","responsePromise","then","response","flightData","flightDataPath","segmentPath","slice","serverRouterState","length","dynamicData","dynamicHead","dynamicLayerAssets","writeDynamicDataIntoPendingTask","abortTask","error","rootTask","i","segment","taskSegment","finishTaskUsingDynamicDataPayload","taskNode","finishPendingCacheNode","serverChildren","dynamicDataChildren","serverRouterStateChild","dynamicDataChild","routerStateChildren","routerStateChild","segmentChild","segmentKeyChild","isLeafSegment","size","maybePrefetchRsc","maybePrefetchLoading","createDeferredRsc","cacheNode","taskState","serverState","taskStateChildren","serverStateChildren","dataChildren","taskStateChild","serverStateChild","dataChild","segmentMapChild","taskSegmentChild","taskSegmentKeyChild","cacheNodeChild","abortPendingCacheNode","dynamicSegmentData","isDeferredRsc","resolve","values","reject","updateCacheNodeOnPopstateRestoration","newParallelRoutes","shouldUsePrefetch","status","DEFERRED","Symbol","value","tag","pendingRsc","Promise","res","rej","fulfilledRsc","rejectedRsc","reason"],"mappings":"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"}