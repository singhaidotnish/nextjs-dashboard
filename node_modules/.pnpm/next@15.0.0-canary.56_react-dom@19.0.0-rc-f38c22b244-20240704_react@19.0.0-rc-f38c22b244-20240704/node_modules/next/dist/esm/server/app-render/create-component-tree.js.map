{"version":3,"sources":["../../../src/server/app-render/create-component-tree.tsx"],"sourcesContent":["import type { FlightSegmentPath, CacheNodeSeedData } from './types'\nimport React, { type ReactNode } from 'react'\nimport { isClientReference } from '../../lib/client-reference'\nimport { getLayoutOrPageModule } from '../lib/app-dir-module'\nimport type { LoaderTree } from '../lib/app-dir-module'\nimport { interopDefault } from './interop-default'\nimport { parseLoaderTree } from './parse-loader-tree'\nimport type { CreateSegmentPath, AppRenderContext } from './app-render'\nimport { createComponentStylesAndScripts } from './create-component-styles-and-scripts'\nimport { getLayerAssets } from './get-layer-assets'\nimport { hasLoadingComponentInTree } from './has-loading-component-in-tree'\nimport { validateRevalidate } from '../lib/patch-fetch'\nimport { PARALLEL_ROUTE_DEFAULT_PATH } from '../../client/components/parallel-route-default'\nimport { getTracer } from '../lib/trace/tracer'\nimport { NextNodeServerSpan } from '../lib/trace/constants'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport type { LoadingModuleData } from '../../shared/lib/app-router-context.shared-runtime'\n\ntype ComponentTree = {\n  seedData: CacheNodeSeedData\n  styles: ReactNode\n}\n\ntype Params = {\n  [key: string]: string | string[]\n}\n\n/**\n * Use the provided loader tree to create the React Component tree.\n */\nexport function createComponentTree(props: {\n  createSegmentPath: CreateSegmentPath\n  loaderTree: LoaderTree\n  parentParams: Params\n  rootLayoutIncluded: boolean\n  firstItem?: boolean\n  injectedCSS: Set<string>\n  injectedJS: Set<string>\n  injectedFontPreloadTags: Set<string>\n  asNotFound?: boolean\n  metadataOutlet?: React.ReactNode\n  ctx: AppRenderContext\n  missingSlots?: Set<string>\n}): Promise<ComponentTree> {\n  return getTracer().trace(\n    NextNodeServerSpan.createComponentTree,\n    {\n      spanName: 'build component tree',\n    },\n    () => createComponentTreeInternal(props)\n  )\n}\n\nfunction errorMissingDefaultExport(pagePath: string, convention: string) {\n  throw new Error(\n    `The default export is not a React Component in \"${pagePath}/${convention}\"`\n  )\n}\n\nasync function createComponentTreeInternal({\n  createSegmentPath,\n  loaderTree: tree,\n  parentParams,\n  firstItem,\n  rootLayoutIncluded,\n  injectedCSS,\n  injectedJS,\n  injectedFontPreloadTags,\n  asNotFound,\n  metadataOutlet,\n  ctx,\n  missingSlots,\n}: {\n  createSegmentPath: CreateSegmentPath\n  loaderTree: LoaderTree\n  parentParams: Params\n  rootLayoutIncluded: boolean\n  firstItem?: boolean\n  injectedCSS: Set<string>\n  injectedJS: Set<string>\n  injectedFontPreloadTags: Set<string>\n  asNotFound?: boolean\n  metadataOutlet?: React.ReactNode\n  ctx: AppRenderContext\n  missingSlots?: Set<string>\n}): Promise<ComponentTree> {\n  const {\n    renderOpts: { nextConfigOutput, experimental },\n    staticGenerationStore,\n    componentMod: {\n      NotFoundBoundary,\n      LayoutRouter,\n      RenderFromTemplateContext,\n      ClientPageRoot,\n      createUntrackedSearchParams,\n      createDynamicallyTrackedSearchParams,\n      serverHooks: { DynamicServerError },\n      Postpone,\n    },\n    pagePath,\n    getDynamicParamFromSegment,\n    isPrefetch,\n    query,\n  } = ctx\n\n  const { page, layoutOrPagePath, segment, components, parallelRoutes } =\n    parseLoaderTree(tree)\n\n  const { layout, template, error, loading, 'not-found': notFound } = components\n\n  const injectedCSSWithCurrentLayout = new Set(injectedCSS)\n  const injectedJSWithCurrentLayout = new Set(injectedJS)\n  const injectedFontPreloadTagsWithCurrentLayout = new Set(\n    injectedFontPreloadTags\n  )\n\n  const layerAssets = getLayerAssets({\n    ctx,\n    layoutOrPagePath,\n    injectedCSS: injectedCSSWithCurrentLayout,\n    injectedJS: injectedJSWithCurrentLayout,\n    injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,\n  })\n\n  const [Template, templateStyles, templateScripts] = template\n    ? await createComponentStylesAndScripts({\n        ctx,\n        filePath: template[1],\n        getComponent: template[0],\n        injectedCSS: injectedCSSWithCurrentLayout,\n        injectedJS: injectedJSWithCurrentLayout,\n      })\n    : [React.Fragment]\n\n  const [ErrorComponent, errorStyles, errorScripts] = error\n    ? await createComponentStylesAndScripts({\n        ctx,\n        filePath: error[1],\n        getComponent: error[0],\n        injectedCSS: injectedCSSWithCurrentLayout,\n        injectedJS: injectedJSWithCurrentLayout,\n      })\n    : []\n\n  const [Loading, loadingStyles, loadingScripts] = loading\n    ? await createComponentStylesAndScripts({\n        ctx,\n        filePath: loading[1],\n        getComponent: loading[0],\n        injectedCSS: injectedCSSWithCurrentLayout,\n        injectedJS: injectedJSWithCurrentLayout,\n      })\n    : []\n\n  const isLayout = typeof layout !== 'undefined'\n  const isPage = typeof page !== 'undefined'\n  const [layoutOrPageMod] = await getTracer().trace(\n    NextNodeServerSpan.getLayoutOrPageModule,\n    {\n      hideSpan: !(isLayout || isPage),\n      spanName: 'resolve segment modules',\n      attributes: {\n        'next.segment': segment,\n      },\n    },\n    () => getLayoutOrPageModule(tree)\n  )\n\n  /**\n   * Checks if the current segment is a root layout.\n   */\n  const rootLayoutAtThisLevel = isLayout && !rootLayoutIncluded\n  /**\n   * Checks if the current segment or any level above it has a root layout.\n   */\n  const rootLayoutIncludedAtThisLevelOrAbove =\n    rootLayoutIncluded || rootLayoutAtThisLevel\n\n  const [NotFound, notFoundStyles] = notFound\n    ? await createComponentStylesAndScripts({\n        ctx,\n        filePath: notFound[1],\n        getComponent: notFound[0],\n        injectedCSS: injectedCSSWithCurrentLayout,\n        injectedJS: injectedJSWithCurrentLayout,\n      })\n    : []\n\n  let dynamic = layoutOrPageMod?.dynamic\n\n  if (nextConfigOutput === 'export') {\n    if (!dynamic || dynamic === 'auto') {\n      dynamic = 'error'\n    } else if (dynamic === 'force-dynamic') {\n      // force-dynamic is always incompatible with 'export'. We must interrupt the build\n      throw new StaticGenBailoutError(\n        `Page with \\`dynamic = \"force-dynamic\"\\` couldn't be exported. \\`output: \"export\"\\` requires all pages be renderable statically because there is not runtime server to dynamic render routes in this output format. Learn more: https://nextjs.org/docs/app/building-your-application/deploying/static-exports`\n      )\n    }\n  }\n\n  if (typeof dynamic === 'string') {\n    // the nested most config wins so we only force-static\n    // if it's configured above any parent that configured\n    // otherwise\n    if (dynamic === 'error') {\n      staticGenerationStore.dynamicShouldError = true\n    } else if (dynamic === 'force-dynamic') {\n      staticGenerationStore.forceDynamic = true\n\n      // TODO: (PPR) remove this bailout once PPR is the default\n      if (\n        staticGenerationStore.isStaticGeneration &&\n        !staticGenerationStore.prerenderState\n      ) {\n        // If the postpone API isn't available, we can't postpone the render and\n        // therefore we can't use the dynamic API.\n        const err = new DynamicServerError(\n          `Page with \\`dynamic = \"force-dynamic\"\\` won't be rendered statically.`\n        )\n        staticGenerationStore.dynamicUsageDescription = err.message\n        staticGenerationStore.dynamicUsageStack = err.stack\n        throw err\n      }\n    } else {\n      staticGenerationStore.dynamicShouldError = false\n      staticGenerationStore.forceStatic = dynamic === 'force-static'\n    }\n  }\n\n  if (typeof layoutOrPageMod?.fetchCache === 'string') {\n    staticGenerationStore.fetchCache = layoutOrPageMod?.fetchCache\n  }\n\n  if (typeof layoutOrPageMod?.revalidate !== 'undefined') {\n    validateRevalidate(layoutOrPageMod?.revalidate, staticGenerationStore.route)\n  }\n\n  if (typeof layoutOrPageMod?.revalidate === 'number') {\n    ctx.defaultRevalidate = layoutOrPageMod.revalidate as number\n\n    if (\n      typeof staticGenerationStore.revalidate === 'undefined' ||\n      (typeof staticGenerationStore.revalidate === 'number' &&\n        staticGenerationStore.revalidate > ctx.defaultRevalidate)\n    ) {\n      staticGenerationStore.revalidate = ctx.defaultRevalidate\n    }\n\n    if (\n      !staticGenerationStore.forceStatic &&\n      staticGenerationStore.isStaticGeneration &&\n      ctx.defaultRevalidate === 0 &&\n      // If the postpone API isn't available, we can't postpone the render and\n      // therefore we can't use the dynamic API.\n      !staticGenerationStore.prerenderState\n    ) {\n      const dynamicUsageDescription = `revalidate: 0 configured ${segment}`\n      staticGenerationStore.dynamicUsageDescription = dynamicUsageDescription\n\n      throw new DynamicServerError(dynamicUsageDescription)\n    }\n  }\n\n  // If there's a dynamic usage error attached to the store, throw it.\n  if (staticGenerationStore.dynamicUsageErr) {\n    throw staticGenerationStore.dynamicUsageErr\n  }\n\n  const LayoutOrPage: React.ComponentType<any> | undefined = layoutOrPageMod\n    ? interopDefault(layoutOrPageMod)\n    : undefined\n\n  /**\n   * The React Component to render.\n   */\n  let Component = LayoutOrPage\n  const parallelKeys = Object.keys(parallelRoutes)\n  const hasSlotKey = parallelKeys.length > 1\n\n  // TODO-APP: This is a hack to support unmatched parallel routes, which will throw `notFound()`.\n  // This ensures that a `NotFoundBoundary` is available for when that happens,\n  // but it's not ideal, as it needlessly invokes the `NotFound` component and renders the `RootLayout` twice.\n  // We should instead look into handling the fallback behavior differently in development mode so that it doesn't\n  // rely on the `NotFound` behavior.\n  if (hasSlotKey && rootLayoutAtThisLevel && LayoutOrPage) {\n    Component = (componentProps: { params: Params }) => {\n      const NotFoundComponent = NotFound\n      const RootLayoutComponent = LayoutOrPage\n      return (\n        <NotFoundBoundary\n          notFound={\n            NotFoundComponent ? (\n              <>\n                {layerAssets}\n                {/*\n                 * We are intentionally only forwarding params to the root layout, as passing any of the parallel route props\n                 * might trigger `notFound()`, which is not currently supported in the root layout.\n                 */}\n                <RootLayoutComponent params={componentProps.params}>\n                  {notFoundStyles}\n                  <NotFoundComponent />\n                </RootLayoutComponent>\n              </>\n            ) : undefined\n          }\n        >\n          <RootLayoutComponent {...componentProps} />\n        </NotFoundBoundary>\n      )\n    }\n  }\n\n  if (process.env.NODE_ENV === 'development') {\n    const { isValidElementType } = require('next/dist/compiled/react-is')\n    if (\n      (isPage || typeof Component !== 'undefined') &&\n      !isValidElementType(Component)\n    ) {\n      errorMissingDefaultExport(pagePath, 'page')\n    }\n\n    if (\n      typeof ErrorComponent !== 'undefined' &&\n      !isValidElementType(ErrorComponent)\n    ) {\n      errorMissingDefaultExport(pagePath, 'error')\n    }\n\n    if (typeof Loading !== 'undefined' && !isValidElementType(Loading)) {\n      errorMissingDefaultExport(pagePath, 'loading')\n    }\n\n    if (typeof NotFound !== 'undefined' && !isValidElementType(NotFound)) {\n      errorMissingDefaultExport(pagePath, 'not-found')\n    }\n  }\n\n  // Handle dynamic segment params.\n  const segmentParam = getDynamicParamFromSegment(segment)\n  /**\n   * Create object holding the parent params and current params\n   */\n  const currentParams =\n    // Handle null case where dynamic param is optional\n    segmentParam && segmentParam.value !== null\n      ? {\n          ...parentParams,\n          [segmentParam.param]: segmentParam.value,\n        }\n      : // Pass through parent params to children\n        parentParams\n  // Resolve the segment param\n  const actualSegment = segmentParam ? segmentParam.treeSegment : segment\n\n  //\n  // TODO: Combine this `map` traversal with the loop below that turns the array\n  // into an object.\n  const parallelRouteMap = await Promise.all(\n    Object.keys(parallelRoutes).map(\n      async (\n        parallelRouteKey\n      ): Promise<[string, React.ReactNode, CacheNodeSeedData | null]> => {\n        const isChildrenRouteKey = parallelRouteKey === 'children'\n        const currentSegmentPath: FlightSegmentPath = firstItem\n          ? [parallelRouteKey]\n          : [actualSegment, parallelRouteKey]\n\n        const parallelRoute = parallelRoutes[parallelRouteKey]\n\n        const notFoundComponent =\n          NotFound && isChildrenRouteKey ? <NotFound /> : undefined\n\n        // if we're prefetching and that there's a Loading component, we bail out\n        // otherwise we keep rendering for the prefetch.\n        // We also want to bail out if there's no Loading component in the tree.\n        let currentStyles = undefined\n        let childCacheNodeSeedData: CacheNodeSeedData | null = null\n\n        if (\n          // Before PPR, the way instant navigations work in Next.js is we\n          // prefetch everything up to the first route segment that defines a\n          // loading.tsx boundary. (We do the same if there's no loading\n          // boundary in the entire tree, because we don't want to prefetch too\n          // much) The rest of the tree is defered until the actual navigation.\n          // It does not take into account whether the data is dynamic — even if\n          // the tree is completely static, it will still defer everything\n          // inside the loading boundary.\n          //\n          // This behavior predates PPR and is only relevant if the\n          // PPR flag is not enabled.\n          isPrefetch &&\n          (Loading || !hasLoadingComponentInTree(parallelRoute)) &&\n          // The approach with PPR is different — loading.tsx behaves like a\n          // regular Suspense boundary and has no special behavior.\n          //\n          // With PPR, we prefetch as deeply as possible, and only defer when\n          // dynamic data is accessed. If so, we only defer the nearest parent\n          // Suspense boundary of the dynamic data access, regardless of whether\n          // the boundary is defined by loading.tsx or a normal <Suspense>\n          // component in userspace.\n          //\n          // NOTE: In practice this usually means we'll end up prefetching more\n          // than we were before PPR, which may or may not be considered a\n          // performance regression by some apps. The plan is to address this\n          // before General Availability of PPR by introducing granular\n          // per-segment fetching, so we can reuse as much of the tree as\n          // possible during both prefetches and dynamic navigations. But during\n          // the beta period, we should be clear about this trade off in our\n          // communications.\n          !experimental.isRoutePPREnabled\n        ) {\n          // Don't prefetch this child. This will trigger a lazy fetch by the\n          // client router.\n        } else {\n          // Create the child component\n\n          if (process.env.NODE_ENV === 'development' && missingSlots) {\n            // When we detect the default fallback (which triggers a 404), we collect the missing slots\n            // to provide more helpful debug information during development mode.\n            const parsedTree = parseLoaderTree(parallelRoute)\n            if (\n              parsedTree.layoutOrPagePath?.endsWith(PARALLEL_ROUTE_DEFAULT_PATH)\n            ) {\n              missingSlots.add(parallelRouteKey)\n            }\n          }\n\n          const { seedData, styles: childComponentStyles } =\n            await createComponentTreeInternal({\n              createSegmentPath: (child) => {\n                return createSegmentPath([...currentSegmentPath, ...child])\n              },\n              loaderTree: parallelRoute,\n              parentParams: currentParams,\n              rootLayoutIncluded: rootLayoutIncludedAtThisLevelOrAbove,\n              injectedCSS: injectedCSSWithCurrentLayout,\n              injectedJS: injectedJSWithCurrentLayout,\n              injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,\n              asNotFound,\n              // The metadataOutlet is responsible for throwing any errors that were caught during metadata resolution.\n              // We only want to render an outlet once per segment, as otherwise the error will be triggered\n              // multiple times causing an uncaught error.\n              metadataOutlet: isChildrenRouteKey ? metadataOutlet : undefined,\n              ctx,\n              missingSlots,\n            })\n\n          currentStyles = childComponentStyles\n          childCacheNodeSeedData = seedData\n        }\n\n        // This is turned back into an object below.\n        return [\n          parallelRouteKey,\n          <LayoutRouter\n            parallelRouterKey={parallelRouteKey}\n            segmentPath={createSegmentPath(currentSegmentPath)}\n            // TODO-APP: Add test for loading returning `undefined`. This currently can't be tested as the `webdriver()` tab will wait for the full page to load before returning.\n            error={ErrorComponent}\n            errorStyles={errorStyles}\n            errorScripts={errorScripts}\n            template={\n              <Template>\n                <RenderFromTemplateContext />\n              </Template>\n            }\n            templateStyles={templateStyles}\n            templateScripts={templateScripts}\n            notFound={notFoundComponent}\n            notFoundStyles={notFoundStyles}\n            styles={currentStyles}\n          />,\n          childCacheNodeSeedData,\n        ]\n      }\n    )\n  )\n\n  // Convert the parallel route map into an object after all promises have been resolved.\n  let parallelRouteProps: { [key: string]: React.ReactNode } = {}\n  let parallelRouteCacheNodeSeedData: {\n    [key: string]: CacheNodeSeedData | null\n  } = {}\n  for (const parallelRoute of parallelRouteMap) {\n    const [parallelRouteKey, parallelRouteProp, flightData] = parallelRoute\n    parallelRouteProps[parallelRouteKey] = parallelRouteProp\n    parallelRouteCacheNodeSeedData[parallelRouteKey] = flightData\n  }\n\n  const loadingData: LoadingModuleData = Loading\n    ? [<Loading />, loadingStyles, loadingScripts]\n    : null\n\n  // When the segment does not have a layout or page we still have to add the layout router to ensure the path holds the loading component\n  if (!Component) {\n    return {\n      seedData: [\n        actualSegment,\n        parallelRouteCacheNodeSeedData,\n        // TODO: I don't think the extra fragment is necessary. React treats top\n        // level fragments as transparent, i.e. the runtime behavior should be\n        // identical even without it. But maybe there's some findDOMNode-related\n        // reason that I'm not aware of, so I'm leaving it as-is out of extreme\n        // caution, for now.\n        <>{parallelRouteProps.children}</>,\n        loadingData,\n      ],\n      styles: layerAssets,\n    }\n  }\n\n  // If force-dynamic is used and the current render supports postponing, we\n  // replace it with a node that will postpone the render. This ensures that the\n  // postpone is invoked during the react render phase and not during the next\n  // render phase.\n  // @TODO this does not actually do what it seems like it would or should do. The idea is that\n  // if we are rendering in a force-dynamic mode and we can postpone we should only make the segments\n  // that ask for force-dynamic to be dynamic, allowing other segments to still prerender. However\n  // because this comes after the children traversal and the static generation store is mutated every segment\n  // along the parent path of a force-dynamic segment will hit this condition effectively making the entire\n  // render force-dynamic. We should refactor this function so that we can correctly track which segments\n  // need to be dynamic\n  if (\n    staticGenerationStore.forceDynamic &&\n    staticGenerationStore.prerenderState\n  ) {\n    return {\n      seedData: [\n        actualSegment,\n        parallelRouteCacheNodeSeedData,\n        <Postpone\n          prerenderState={staticGenerationStore.prerenderState}\n          reason='dynamic = \"force-dynamic\" was used'\n          route={staticGenerationStore.route}\n        />,\n        loadingData,\n      ],\n      styles: layerAssets,\n    }\n  }\n\n  const isClientComponent = isClientReference(layoutOrPageMod)\n\n  // We avoid cloning this object because it gets consumed here exclusively.\n  const props: { [prop: string]: any } = parallelRouteProps\n\n  // If it's a not found route, and we don't have any matched parallel\n  // routes, we try to render the not found component if it exists.\n  if (\n    NotFound &&\n    asNotFound &&\n    // In development, it could hit the parallel-route-default not found, so we only need to check the segment.\n    // Or if there's no parallel routes means it reaches the end.\n    !parallelRouteMap.length\n  ) {\n    props.children = (\n      <>\n        <meta name=\"robots\" content=\"noindex\" />\n        {process.env.NODE_ENV === 'development' && (\n          <meta name=\"next-error\" content=\"not-found\" />\n        )}\n        {notFoundStyles}\n        <NotFound />\n      </>\n    )\n  }\n\n  // Assign params to props\n  if (\n    process.env.NODE_ENV === 'development' &&\n    'params' in parallelRouteProps\n  ) {\n    // @TODO consider making this an error and running the check in build as well\n    console.error(\n      `\"params\" is a reserved prop in Layouts and Pages and cannot be used as the name of a parallel route in ${segment}`\n    )\n  }\n  props.params = currentParams\n\n  let segmentElement: React.ReactNode\n  if (isPage) {\n    // Assign searchParams to props if this is a page\n    if (isClientComponent) {\n      // When we are passing searchParams to a client component Page we don't want to track the dynamic access\n      // here in the RSC layer because the serialization will trigger a dynamic API usage.\n      // Instead we pass the searchParams untracked but we wrap the Page in a root client component\n      // which can among other things adds the dynamic tracking before rendering the page.\n      // @TODO make the root wrapper part of next-app-loader so we don't need the extra client component\n      props.searchParams = createUntrackedSearchParams(query)\n      segmentElement = (\n        <>\n          {metadataOutlet}\n          <ClientPageRoot props={props} Component={Component} />\n        </>\n      )\n    } else {\n      // If we are passing searchParams to a server component Page we need to track their usage in case\n      // the current render mode tracks dynamic API usage.\n      props.searchParams = createDynamicallyTrackedSearchParams(query)\n      segmentElement = (\n        <>\n          {metadataOutlet}\n          <Component {...props} />\n        </>\n      )\n    }\n  } else {\n    // For layouts we just render the component\n    segmentElement = <Component {...props} />\n  }\n\n  return {\n    seedData: [\n      actualSegment,\n      parallelRouteCacheNodeSeedData,\n      <>\n        {segmentElement}\n        {/* This null is currently critical. The wrapped Component can render null and if there was not fragment\n            surrounding it this would look like a pending tree data state on the client which will cause an error\n            and break the app. Long-term we need to move away from using null as a partial tree identifier since it\n            is a valid return type for the components we wrap. Once we make this change we can safely remove the\n            fragment. The reason the extra null here is required is that fragments which only have 1 child are elided.\n            If the Component above renders null the actual tree data will look like `[null, null]`. If we remove the extra\n            null it will look like `null` (the array is elided) and this is what confuses the client router.\n            TODO-APP update router to use a Symbol for partial tree detection */}\n        {null}\n      </>,\n      loadingData,\n    ],\n    styles: layerAssets,\n  }\n}\n"],"names":["React","isClientReference","getLayoutOrPageModule","interopDefault","parseLoaderTree","createComponentStylesAndScripts","getLayerAssets","hasLoadingComponentInTree","validateRevalidate","PARALLEL_ROUTE_DEFAULT_PATH","getTracer","NextNodeServerSpan","StaticGenBailoutError","createComponentTree","props","trace","spanName","createComponentTreeInternal","errorMissingDefaultExport","pagePath","convention","Error","createSegmentPath","loaderTree","tree","parentParams","firstItem","rootLayoutIncluded","injectedCSS","injectedJS","injectedFontPreloadTags","asNotFound","metadataOutlet","ctx","missingSlots","renderOpts","nextConfigOutput","experimental","staticGenerationStore","componentMod","NotFoundBoundary","LayoutRouter","RenderFromTemplateContext","ClientPageRoot","createUntrackedSearchParams","createDynamicallyTrackedSearchParams","serverHooks","DynamicServerError","Postpone","getDynamicParamFromSegment","isPrefetch","query","page","layoutOrPagePath","segment","components","parallelRoutes","layout","template","error","loading","notFound","injectedCSSWithCurrentLayout","Set","injectedJSWithCurrentLayout","injectedFontPreloadTagsWithCurrentLayout","layerAssets","Template","templateStyles","templateScripts","filePath","getComponent","Fragment","ErrorComponent","errorStyles","errorScripts","Loading","loadingStyles","loadingScripts","isLayout","isPage","layoutOrPageMod","hideSpan","attributes","rootLayoutAtThisLevel","rootLayoutIncludedAtThisLevelOrAbove","NotFound","notFoundStyles","dynamic","dynamicShouldError","forceDynamic","isStaticGeneration","prerenderState","err","dynamicUsageDescription","message","dynamicUsageStack","stack","forceStatic","fetchCache","revalidate","route","defaultRevalidate","dynamicUsageErr","LayoutOrPage","undefined","Component","parallelKeys","Object","keys","hasSlotKey","length","componentProps","NotFoundComponent","RootLayoutComponent","params","process","env","NODE_ENV","isValidElementType","require","segmentParam","currentParams","value","param","actualSegment","treeSegment","parallelRouteMap","Promise","all","map","parallelRouteKey","isChildrenRouteKey","currentSegmentPath","parallelRoute","notFoundComponent","currentStyles","childCacheNodeSeedData","isRoutePPREnabled","parsedTree","endsWith","add","seedData","styles","childComponentStyles","child","parallelRouterKey","segmentPath","parallelRouteProps","parallelRouteCacheNodeSeedData","parallelRouteProp","flightData","loadingData","children","reason","isClientComponent","meta","name","content","console","segmentElement","searchParams"],"mappings":"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"}