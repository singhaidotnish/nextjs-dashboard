"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
0 && (module.exports = {
    ErrorHandlerSource: null,
    createErrorHandler: null
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    ErrorHandlerSource: function() {
        return ErrorHandlerSource;
    },
    createErrorHandler: function() {
        return createErrorHandler;
    }
});
const _stringhash = /*#__PURE__*/ _interop_require_default(require("next/dist/compiled/string-hash"));
const _formatservererror = require("../../lib/format-server-error");
const _tracer = require("../lib/trace/tracer");
const _pipereadable = require("../pipe-readable");
const _bailouttocsr = require("../../shared/lib/lazy-dynamic/bailout-to-csr");
const _isnavigationsignalerror = require("../../export/helpers/is-navigation-signal-error");
const _hooksservercontext = require("../../client/components/hooks-server-context");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const ErrorHandlerSource = {
    serverComponents: 'serverComponents',
    flightData: 'flightData',
    html: 'html'
};
function createErrorHandler({ /**
   * Used for debugging
   */ source, dev, isNextExport, errorLogger, digestErrorsMap, allCapturedErrors, silenceLogger }) {
    return (err, errorInfo)=>{
        var _err_message;
        // If the error already has a digest, respect the original digest,
        // so it won't get re-generated into another new error.
        if (!err.digest) {
            // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.
            err.digest = (0, _stringhash.default)(err.message + ((errorInfo == null ? void 0 : errorInfo.stack) || err.stack || '')).toString();
        }
        const digest = err.digest;
        if (allCapturedErrors) allCapturedErrors.push(err);
        // If the response was closed, we don't need to log the error.
        if ((0, _pipereadable.isAbortError)(err)) return;
        // If we're bailing out to CSR, we don't need to log the error.
        if ((0, _bailouttocsr.isBailoutToCSRError)(err)) return err.digest;
        // If this is a navigation error, we don't need to log the error.
        if ((0, _isnavigationsignalerror.isNavigationSignalError)(err)) return err.digest;
        if (!digestErrorsMap.has(digest)) {
            digestErrorsMap.set(digest, err);
        } else if (source === ErrorHandlerSource.html) {
            // For SSR errors, if we have the existing digest in errors map,
            // we should use the existing error object to avoid duplicate error logs.
            err = digestErrorsMap.get(digest);
        }
        // If this error occurs, we know that we should be stopping the static
        // render. This is only thrown in static generation when PPR is not enabled,
        // which causes the whole page to be marked as dynamic. We don't need to
        // tell the user about this error, as it's not actionable.
        if ((0, _hooksservercontext.isDynamicServerError)(err)) return err.digest;
        // Format server errors in development to add more helpful error messages
        if (dev) {
            (0, _formatservererror.formatServerError)(err);
        }
        // Used for debugging error source
        // console.error(source, err)
        // Don't log the suppressed error during export
        if (!(isNextExport && (err == null ? void 0 : (_err_message = err.message) == null ? void 0 : _err_message.includes('The specific message is omitted in production builds to avoid leaking sensitive details.')))) {
            // Record exception in an active span, if available.
            const span = (0, _tracer.getTracer)().getActiveScopeSpan();
            if (span) {
                span.recordException(err);
                span.setStatus({
                    code: _tracer.SpanStatusCode.ERROR,
                    message: err.message
                });
            }
            if (!silenceLogger && // Only log the error from SSR rendering errors and flight data render errors,
            // as RSC renderer error will still be pipped into SSR renderer as well.
            source === 'html' || source === 'flightData') {
                if (errorLogger) {
                    errorLogger(err).catch(()=>{});
                } else {
                    // The error logger is currently not provided in the edge runtime.
                    // Use the exposed `__next_log_error__` instead.
                    // This will trace error traces to the original source code.
                    if (typeof __next_log_error__ === 'function') {
                        __next_log_error__(err);
                    } else {
                        console.error(err);
                    }
                }
            }
        }
        return err.digest;
    };
}

//# sourceMappingURL=create-error-handler.js.map